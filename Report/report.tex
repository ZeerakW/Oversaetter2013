\documentclass[10pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{array}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{epstopdf}
%\usepackage{minted}
\usepackage{verbments}

\title{A Compiler for the \textbf{Paladim} Language}
\author{
    Klaus MÃ¸llnitz\\
    nhg665
  \and
    Konstantin Slavin-Borovskij\\
    wfb603
  \and
    Zeerak Waseem\\
    csp265
}
\begin{document}
\maketitle

\newpage
\tableofcontents
\section{Introduction}
In this report we will document the changes we have made to the Paladim language. 

We were given the assignment to implement certain tasks. For this report, we were asked to implement a parser, integer multiplication, division, and boolean operators, type inference and type checking for the \texttt{new} function, type checking and array indexing, and call-by-value-result semantics for procedures in the Paladim compiler.

We have written our testing section for each sub section in the analysis, so as to add a greater coherence between the implemented tasks and the test of these. All edited code can be found in the appendices.

\section{Background}

We will briefly introduce the nature of the changes for each of the tasks given. The tasks given were:
\begin{itemize}
\item Implement a parser for the Paldim language
\item Implement integer division and multiplication and boolean operators in the Paladim compiler
\item Type inference and type checking for the \texttt{new} function
\item Type checking and code generation for Array Indexing
\item Call-By-Value-Result semantics for procedures
\end{itemize}

% TODO Add parser.grm to appendices label: Appendix:Parser.grm
The parser was implemented by creating a new grammar file, which can be seen in \ref{Appendix:Parser.grm}. It can also be found in the \texttt{SRC} folder.

% TODO Integer Multiplication, division and boolean operation need to be explained
For the integer multiplication, division and boolean operations; we initially edited the \texttt{TpAbsyn.sml} file to reflect the operations we wished to implement (\texttt{times, divide, or, not}), we then edited Compiler.sml, where we implemented the translation to \texttt{MIPS}, we then edited \texttt{TpInterpret.sml} where we implemented the interpretation, finally we edited \texttt{Type.sml} where we ensure that the types correspond to the desired values.

% TODO Type inference and type checking for the new function need to be explained
For the \texttt{new \& read} functions, we edited \texttt{Type.sml} to implement simple type inference and type checking. This is done in \texttt{typeCheckExp}.

% TODO Type checking and array indexing need to be explained
To implement type checking and array indexing for arrays, we edited \texttt{Type.sml} to reflect required changes for array handling. Further, we edited the \texttt{compileLVal} function in \texttt{Compiler.sml} to support translation to machine code.

% TODO Call-By-Value-Result semantics for procedures
To implement Call-By-Value-Result semantics we have edited \texttt{TpInterpret.sml}, implementing \texttt{updateOuterVtable}. Furthermore we have also extended \texttt{Compiler.sml} to support code generation for Call-By-Value-Result interpretation, by implementing a new function named \texttt{rePutArgs}.

\section{Analysis}
\subsection{Parser}
\subsubsection{Identifying tokens}
In our abstract parser definition most of our tokens use the type $<int*int>$. This type is the position of the token, which is constructed by line and column. If nothing is stated in the tables, this is the type used.

We have identified the list of terminals and given each a keyword, for later use in the abstract parser definition.

All the keywords of the Paladim language is listed in table \ref{tab:keywords}, these only use the positional data, meaning they all have token type $<int*int>$, since we have chosen to denote the position by linenumber and column in the line.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\textbf{program} & PROGRAM \\
\textbf{function} & FUNCTION \\
\textbf{procedure} & PROCEDURE \\
\textbf{var} & VAR \\
\textbf{begin} & BEGIN \\
\textbf{end} & END \\
\textbf{if} & IF \\
\textbf{then} & THEN \\
\textbf{else} & ELSE \\
\textbf{while} & WHILE \\
\textbf{do} & DO \\
\textbf{return} & RETURN \\
\hline
\end{tabular}
\caption{\label{tab:keywords}Keywords}
\end{table}

We also need keywords for the specific types, since we should be able to write the following as noted in (\ref{eq:varname_type}). The keyword is written in table \ref{tab:type_keywords}.
\begin{align}
\label{eq:varname_type}
\text{VariableName} \textbf{ : } \text{Type}. 
\end{align}

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\textbf{int} & INT \\
\textbf{char} & CHAR \\
\textbf{bool} & BOOL \\
\textbf{array} & ARRAY \\
\textbf{of} & OF \\
\hline
\end{tabular}
\caption{\label{tab:type_keywords}Type keywords}
\end{table}

Next terminals we need to consider is symbols. These are very simple and shown in table \ref{tab:symbols}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\textbf{;} & SEMICOLON \\
\textbf{:} & COLON \\
\textbf{,} & COMMA \\
\textbf{:=} & ASSIGN \\
\textbf{EOF} & EOF \\
\hline
\end{tabular}
\caption{\label{tab:symbols}Symbols}
\end{table}

All arithmetic operators is found in table \ref{tab:arithmetics}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\text{+} & PLUS \\
\text{-} & MINUS \\
\text{*} & TIMES \\
\text{/} & DIVIDE \\
\text{=} & EQUAL \\
\text{<} & LESS \\
\textbf{AND} & AND \\
\textbf{OR} & OR \\
\textbf{NOT} & NOT \\
\hline
\end{tabular}
\caption{\label{tab:arithmetics}Arithmetics}
\end{table}

Parantheses is covered in table \ref{tab:parentheses}. They have been given their own table as to represent the structure of the lexer. 

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\text{(} & LPAR \\
\text{)} & RPAR \\
\text{\{} & LCBR \\
\text{\}} & RCBR \\
\text{[} & LBRA \\
\text{]} & RBRA \\
\hline
\end{tabular}
\caption{\label{tab:parentheses}Parentheses}
\end{table}

Finally we have all of the literals, which are supposed to contain both data and a position. As seen in table \ref{tab:literals}, they all make use of some sort of variable to store their content. We also cover the Identifier here.

\begin{table}[!h]
\centering
\begin{tabular}{|c|c|c|}
\hline
Terminal & Keyword & Type\\
\hline
\textbf{ID} & ID & <string*(int*int)>\\
\textbf{NUMLIT} & NUMLIT & <int*(int*int)>\\
\textbf{LOGICLIT} & LOGLIT & <bool*(int*int)> \\
\textbf{CHARLIT} & CHALIT & <char*(int*int)> \\
\textbf{STRINGLIT} & STRLIT & <string*(int*int)> \\
\hline
\end{tabular}
\caption{\label{tab:literals}Literals}
\end{table}

\subsubsection{Precedence}
Next task is to denote the precedence of the operators as in table \ref{tab:op_precedence}. The operators are listed by importance, top to bottom. Each operator is given a precedence score ranging from \(1-8\). Finally each operator will have its associativity denoted. According to the assignment, all of the binary operators should be left-associative.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Name & Precedence & Associativity\\
\hline
TIMES & 1 & Left\\
DIVIDE & 1 & Left\\
PLUS & 2 & Left\\
MINUS & 2 & Left\\
EQUAL & 3 & Left\\
LESS & 3 & Left\\
NOT & 4 & Left\\
AND & 5 & Left\\
OR & 6 & Left\\
ELSE & 7 & Non Associative\\
OptElse & 8 & Non Associative\\
\hline
\end{tabular}
\end{center}
\caption{\label{tab:op_precedence}Operator Precedence}
\end{table}

\subsubsection{Productions}
Last task for making the compiler is to write down each of the productions. We ran into a few problems with the handed out language, with both the operators between expression $Exp \rightarrow Exp \text{ OP } Exp$ but also $Exp \rightarrow LVal$. These issues got solved, by substituting the productions into the production for $Exp$.

\subsubsection{Linking parser}
The last step to create a new parser, is to link the compiler to use the new implementation of the SLR(1) parser, instead of the handed out LL(1) parser. This was done in the file \textit{"Driver.sml"}.

\subsubsection{Testing Parser}
We have tested our parser implementation with a new test file we have created for the purpose, called \textit{"parserTest.pal"}. This file is testing pretty much all of the different productions used in the language. We got all of them to work like they should. To test the parser while the type checker was not implemented, we simply noted if the Paladim program would fail with \texttt{parser error} or \texttt{type checking error}, if the last was the case, it meant the parser did the job correctly since its a typechecker error, hence the compiler proceeded after parse checking.

\subsection{Integer multiplication/division and boolean operators}
The multiplication, division and boolean operators is all fully supported by the parser, next task is to implement the features in the type checker.

To implement the features in the Paladim compiler, we initially edited the typed abstract syntax tree, \texttt{TpAbsyn.sml}, by adding \texttt{Times \& Div} types to the \texttt{typeOfExp} function. This function should simply just return the type of first operand, since the type check makes sure both operands are of same type. Another important thing to add in this file is the pretty printing of the expressions, since the Interpreter is using the pretty printing functionsto show the code to the user. It is done in a similar matter to the pretty printing of \texttt{Plus} and \texttt{Minus}.

We then edited the type checker, \texttt{Type.sml}, extending the function \texttt{typeCheckExp}. The two functions is implemented by doing a type check recursively of the expressions on both sides of the multiplication or the division operator. The results is compared with the type \texttt{INT}, to make sure both have correct type, if this is not the case we raise an error.

The same has been done for the \texttt{OR \& NOT} operators, correspondingly changing the typecheck from \texttt{INT} to \texttt{BOOL}. Furthermore, seeing as \texttt{NOT} is a unary operator we have ensured that the check is only done for one expression, rather than two, as with the rest of the operators we were to implement.

\subsubsection{Multiplication, division and boolean operators in interpreter}
Since multiplication, division and the boolean operators is now implemented in the type checker, it needs to be implemented in the compiler and the interpreter. Here we cover how we achieved this in the interpreter. The interpreter is implemented in the file \texttt{TpInterpret.sml}, hence we need to add the missing functions in there.

The interpreter can expect to get type checked expression, therefore we can simply just evaluate each operand of the expression, and calculate the result, just like with \texttt{Plus} and \texttt{Minus}. This is very trivial for both, the only thing to note here, is in division we have to use the SML function called div, since we are interested in integer division and not floating point division.

Finally we also need to implement the boolean operators in the interpreter. Since the boolean operator \texttt{AND} is already implemented, we decided to implement \texttt{OR} and \texttt{NOT} in the same style, by having a function to evaluate each of the expression respectively \texttt{evalOR} and \texttt{evalNOT}. These helper functions simply calculate \texttt{OR} and \texttt{NOT} by using the SML functions \texttt{orelse} and \texttt{not}. The interpreter is evaluating each of the operands to the function before calling the helper functions, which means the helper function is simply gonna get one or two arguments respectively.
% TODO, maybe add some lines of code to show proof-of-concept

\subsubsection{Multiplication, division and boolean operators in compiler}
Finally to implement the features in the compiler, we edited the \texttt{Compilers.sml} file.

To implement the boolean operators in the compiler, we used the same approach as with the \texttt{AND} operator. The function should return a list of Mips instructions to achieve this task, hence the beginning of the list should be the output of the function \texttt{compileExp} with the first operand as argument. The list is then followed with some code that check if the first operand is different from zero (meaning the expression is true), if this is the case, it would branch to a label in the end of the expression, since there is no need to check more. If the first operand is indeed zero, there should be no branching, and the second operand should be checked, hence the result is that of \texttt{compileExp} of second operand.

The expression \texttt{NOT} is implemented in a similar manner, by using the \texttt{XORI} instruction from the \texttt{MIPS} library on the register containing the value to be negated (by using the function \texttt{compileExp}.

Muliplication and division is a bit more simple, they basically just compile each of the operands with \texttt{compileExp}, and then append the \texttt{MIPS} instructions \texttt{MUL} and \texttt{DIV} accordingly.

\subsubsection{Testing Multiplication, Division, and Boolean Operators}
A number of tests was done, to check that the multiply and divide operators, as well as the boolean operators \texttt{OR \& NOT}, are behaving as expected. The tests is available in \texttt{DATA\textbackslash parserTest.pal}, which both test a lot of parser-related functionality, but also includes testing of the aforementioned operators.

This results does not need much explanation, as the expected results are trivial. But running the tests, confirm that the operators behave as desired.

% TODO I'm working here !! :) - Klaus
\subsection{Type inference \& Type Checking}
\subsubsection{Type Inference}
This section explains how we chose to implement type inference and type checking, focusing on what was needed to implement these properties into the Paladim compiler.

The implementation for type checking of the \texttt{read}-function, was done in \texttt{Type.sml}. The type checking is done by checking what type expression is passed to the function, and from that determining an expected type of \texttt{read}. If the expression contains a specific operator, it is possible to determine what type, the subexpression are expected to be, and let \texttt{read} inherit this property.

For simplicity, the type checking implemented, only works if it is possible to determine at least the right-hand side of an expression, as implementing all possible cases was not required. This means, that the left-hand subexpression determines the expected type of the right-hand side subexpression. Furthermore, since there is no unique way of determining the type of an expression like \texttt{read() = read()}, there is no implementation to deal with this case, and the type checking will most likely fail.

The implementation demands that for example the \texttt{assign} operator must give an expected type to its subexpressions, in our case we first calculate the type of the left-hand side of the operator, then give it as expected type to the right-hand side. In the following pseudocode, the first one would succeed, but the latter would not because of aforementioned problems. The expected types has been implemented to all relevant operators including plus, minus, division etc.
\begin{align}
INT &= read()\\
read() &= INT
\end{align}

\subsubsection{Type checking the new-function}
The function \texttt{new} is also implemented by extending the \texttt{typeCheckExp}-function in \texttt{Type.sml}. The function generate a list of arguments which is type checked. This list is then used to calculate another list containing the types of all arguments. This new list is then recursively compared against the \texttt{INT} type. If all arguments is \texttt{INT} the variable called \texttt{tpok} would be true, otherwise false. Then the rank of the array is calculated and the return type is created. If the rank is bigger than zero, and the variable \texttt{tpok} is true, the function will return the \texttt{FunApp} datatype from \texttt{TpAbSyn.sml}. The arguments to this datatype is the list of arguments calculated in the beginning, since these arguments is also containing the type of the expressions, which is required in the typed abstract syntax tree.

\subsubsection{Testing Type Inference \& Type Checking}
The testing of type inference and type checking is done in \texttt{DATA\textbackslash parterTest.pal}, line 83-93. The lines are currently commented out, since this specific test file is used to test other features of the compiler. First we test the provided case like in (\ref{eq:read}). All of our test went as expected.

\begin{align}
\label{eq:read}
chr(read()) = read()
\end{align}

\subsection{Array Indexing}
\subsubsection{Type checking of array indexing}
To implement array indexing, we needed to extend the type checker to include this case. We followed the suggested implementation steps. At first we look up the array in the variable table and extracts the type. Next we check that the provided variable is an array, and in case we extract the rank of the array from the symbol table. We then in a similar matter to type checking of the new function, check if all arguments is \texttt{INT}, since indexing can only be succeeded with integers. The result of this typecheck is put into the variable \texttt{tpok}. Lastly the rank of the provided indexing is calculated, to compare with the rank from the symbol table.

If the variable \texttt{tpok} is true, meaning all arguments is integers, and the rank provided is bigger than zero, we just need to check wether the rank provided is the same as the rank in the symbol table, is this not the case, then the array is indexed wrongly, hence we need to raise an error. Otherwise we can proceed creating and returning a new \texttt{LValue} datatype of an array (with types).

\subsubsection{Array indexing in compiler}
To implement the array indexing, we have made 2 helper functions. The function checkInds which generate MIPS code to check if the indexing is inside the boundaries. Another function computeFlatIndex is used to generate MIPS code which calculate the index as a flat array representation, by using the method described in the assignment. The two functions are described in more detail after this section.

The first thing the compiler should do is to look up the array in the symbol table. This will return a register, which keeps the location to the beginning of the array. Then the output from the two helper functions is added. At last the type of the array is used to determine wether the flat index computed should be multiplied by four. This is the case if the array contains integers, since an integer uses four bytes in memory compared to characters and logic variables which all use only one byte. The multiplication is done by using the \texttt{MIPS} expression \texttt{SLL} (shift-left-logical), which is more efficient than using \texttt{MUL}.

Furthermore the array header containing the dimension and strides need to be added to the flat index, this is done by taking the amount of indexes and multiply by eight (dimension and strides takes one word of space which is four bytes). Finally the current location in memory has to be added to get the direct location in memory where our index is located.

The register to the final location is returned together with all the MIPS code to calculate the location.

\subsubsection*{BONUS: Calculating flat index without strides}
As stated in the assignment it is possible to calculate the flat index without use of the stored strides. This is because the strides are simply calculated from dimensions. As example the first stride is the all of the dimension except the first one multiplied together, this could easily be calculated in MIPS, instead of loading the stride from the memory, it should calculate the stride and put in a new register.
%, meaning the dimension of the array should be multiplied with the dimension 
%Bonus: The computation of the flat index into the arrayâs content can be accomplished in a manner of similar efficiency to the one described in Section 3.2.3, but which uses only the arrayâs dimension sizes (and not its strides). A bonus will be offered if you present how this may be accomplished and/or if you actually implement it (instead of the suggested solution).

\subsubsection{Testing Array Indexing}
The array indexing is tested in file \texttt{arrayInd.pal}, we decided to test arrays of both integers and characters. We test both assigning a value to the array, but also reading an value. In addition we tested the cases where the indexing was out of boundaries, and where the indexing is not integers at all (characters). All tests went as expected.

We have furthermore tested our implementations of various kind with the provided test files.

\subsection{Call-by-value-result semantics}
The last thing to implement in our compiler is call-by-value-result policy for procedures. This means that all variables a procedure takes as arguments, should be updated once the procedure is ending. Every single time a function or procedure is called, a new symbol table is created, our approach to implement this policy is to match the actual and formal arguments, and use the value in the new symbol table to update the former symbol table. The policy needs to be implemented in both the interpreter and compiler, which is stated in the following two sections.

\subsection{Call-by-value-result in interpreter}
This policy is implemented in interpreter by editing the function \texttt{callFun}. The function extract the return type of the Paladim function and uses this to determine wether the Paladim function is a function or procedure. If it is a procedure, it wouldn't have any return type. If that is the case, it should simply execute our helper function called \texttt{updateOuterVtable}, with the former and new symbol tables, and the list of formal and actual arguments.

Our helper function first extracts a list of strings from the list of actual arguments. This list is used the generate another list, which is the indexes of the argument list. The second list is used to iterate over all of the arguments and for each of the arguments, the actual argument is looked up in the new symbol table, this gives us the location to an address which contains the location of the value of the actual argument. The next step is to look up the formal argument in the former symbol table, and update this value with the result from the actual argument. In the end the function returns \texttt{NONE}, since a procedure should not return anything.

\subsection{Call-by-value-result in compiler}
To implement the policy in the compiler, we have to edit the \texttt{compileF} and \texttt{compileStmt} functions in the compiler. First of all in \texttt{compileStmt}, we need to edit the generated \texttt{MIPS} code such that the arguments which are put into register by the function \texttt{putArgs} is moved back again after the procedure terminates. To do this, we have created a similar function to \texttt{putArgs}, called \texttt{rePutArgs}, this new function basically just does the inverse of \texttt{putArgs}. We also had to change the tabulate list to start from minReg instead of zero. This is because the arguments used in the procedures start with the lowest register as minReg. Finally the new functions output should be put after the \texttt{MIPS JAL} instruction.

Our helper function \texttt{rePutArgs} extracts the first expression and corresponding register from the arguments. Then it extract the name of the expression to look it up in the symbol table. The registers value is then moved to the address from the symbol table. The rest of the list is appended by recursively using the same function.

The last place to edit for enabling the policy for procedures is the \texttt{compileF} function. This function is running the register allocator, which in our case has to be modified, since we do not use register two for a return value. Instead the register allocator needs to have all of the used registers in our procedure (the arguments). Furthermore we also needed to add the MIPS code to move the variables back to registers. This second task is achieved by simply using a reverse map of \texttt{argcode}, we have called it \texttt{argcode\_rev}. The first task is achieved by extracting all the registers with map from the movePairs function provided.

\subsubsection{Testing Call-by-Value-Result semantics}
Our call-by-value-result policy is tested by using the provided test files together with our own test file. The files used for testing are the following.
\begin{itemize}
\item{\texttt{DATA\textbackslash procReturnSimul.pal}}
\item{\texttt{DATA\textbackslash procSwap.pal}}
\item{\texttt{DATA\textbackslash proctest.pal}}
\end{itemize}

All test went as expected, without issues.

\section{Conclusion}
%The milestone has been met, according to the assignment specification. The tests clearly indicate this.
The compilers demands has been met, according to the assignment specification. All of the test are being called without unexpected results.

We have successfully implemented parser, type checker, code generator and interpreter of all asked features. All of the tests has been executed with the MARS simulator, to verify the solution is working as stated.

%\section{Bibliography}
\begin{thebibliography}{9}
\bibitem{springer2011}
Torben Ãgidius Mogensen,
\emph{Introduction to Compiler Design}.
Springer London,
2011.

%\bibitem{slide:interpretation}
%Slide
\end{thebibliography}

%\section*{A }
%Write here \ldots

\end{document}
