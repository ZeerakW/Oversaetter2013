\documentclass[10pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{array}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{epstopdf}
%\usepackage{minted}
\usepackage{verbments}

\title{A Compiler for the \textbf{Paladim} Language}
\author{
    Klaus Møllnitz\\
    nhg665
  \and
    Konstantin Slavin-Borovskij\\
    wfb603
  \and
    Zeerak Waseem\\
    csp265
}
\begin{document}
\maketitle

\newpage
\tableofcontents
\section{Introduction}
In this report we will document the changes we have made to the Paladim language thus far.

We were given the assignment to implement certain tasks. For this status report, we were asked to implement a parser for the Paladim language.

The parser was implemented by creating a new grammar file, which has been handed in with this assignment, it can be found in the \texttt{SRC} folder.

\section{Background}

% TODO: Not sure what to write here that hasn't already been stated in the introduction. Any suggestions?

%\pgfversion
%%\begin{dot2tex}
%digraph {
%  rankdir = LR;
%  node [shape=circle];
%  start [color=white, shape=plaintext];
%  q2 [shape=doublecircle];
%  start -> q1;
%  q1 -> q1 [label="a"];
%  q2 -> q2 [label="a"];
%  q1 -> q2 [label="b"];
%  q2 -> q1 [label="b"];
%}
%\end{dot2tex}

\section{Analysis}
\subsection{Parser}
\subsubsection{Identifying tokens}
In our abstract parser definition most of our tokens use the type $<int*int>$. This type is the position of the token, which is constructed by line and column. If nothing is stated in the tables, this is the type used.

We have identified the list of terminals and given each a keyword, for later use in the abstract parser definition.

All the keywords of the Paladim language is listed in table \ref{tab:keywords}, these only use the positional data, meaning they all have token type $<int*int>$, since we have chosen to denote the position by linenumber and column in the line.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
Terminal & Keyword \\
\hline
\textbf{program} & PROGRAM \\
\textbf{function} & FUNCTION \\
\textbf{procedure} & PROCEDURE \\
\textbf{var} & VAR \\
\textbf{begin} & BEGIN \\
\textbf{end} & END \\
\textbf{if} & IF \\
\textbf{then} & THEN \\
\textbf{else} & ELSE \\
\textbf{while} & WHILE \\
\textbf{do} & DO \\
\textbf{return} & RETURN \\
\hline
\end{tabular}
\caption{\label{tab:keywords}Keywords}
\end{table}

We also need keywords for the specific types, since we should be able to write the following as noted in (\ref{eq:varname_type}). The keyword is written in Table \ref{tab:type_keywords}.
\begin{align}
\label{eq:varname_type}
\text{VariableName} \textbf{ : } \text{Type}. 
\end{align}

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
Terminal & Keyword \\
\hline
\textbf{int} & INT \\
\textbf{char} & CHAR \\
\textbf{bool} & BOOL \\
\textbf{array of} & ARRAYOF \\
\textbf{of} & OF \\
\hline
\end{tabular}
\caption{\label{tab:type_keywords}Type keywords}
\end{table}

Next terminals we need to consider is symbols. These are very simple and shown in table \ref{tab:symbols}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
Terminal & Keyword \\
\hline
\textbf{;} & SEMICOLON \\
\textbf{:} & COLON \\
\textbf{,} & COMMA \\
\textbf{:=} & ASSIGN \\
\textbf{EOF} & EOF \\
\hline
\end{tabular}
\caption{\label{tab:symbols}Symbols}
\end{table}

All arithmetic operators is found in table \ref{tab:arithmetics}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
Terminal & Keyword \\
\hline
\text{+} & PLUS \\
\text{-} & MINUS \\
\text{*} & TIMES \\
\text{/} & DIVIDE \\
\text{=} & EQUAL \\
\text{<} & LESS \\
\textbf{AND} & AND \\
\textbf{OR} & OR \\
\textbf{NOT} & NOT \\
\hline
\end{tabular}
\caption{\label{tab:arithmetics}Arithmetics}
\end{table}

Parantheses is covered in table \ref{tab:parentheses}. They have been given their own table as to represent the structure of the lexer. 

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
Terminal & Keyword \\
\hline
\text{(} & LPAR \\
\text{)} & RPAR \\
\text{\{} & LCBR \\
\text{\}} & RCBR \\
\text{[} & LBRA \\
\text{]} & RBRA \\
\hline
\end{tabular}
\caption{\label{tab:parentheses}Parentheses}
\end{table}

Finally we have all of the literals, which are supposed to contain both data and a position. As seen in table \ref{tab:literals}, they all make use of some sort of variable to store their content. We also cover the Identifier here.

\begin{table}[!h]
\centering
\begin{tabular}{|c|c|c|}
Terminal & Keyword & Type\\
\hline
\textbf{ID} & ID & <string*(int*int)>\\
\textbf{NUMLIT} & NUMLIT & <int*(int*int)>\\
\textbf{LOGICLIT} & LOGLIT & <bool*(int*int)> \\
\textbf{CHARLIT} & CHALIT & <char*(int*int)> \\
\textbf{STRINGLIT} & STRLIT & <string*(int*int)> \\
\hline
\end{tabular}
\caption{\label{tab:literals}Literals}
\end{table}

\subsubsection{Precedence}
Next task is to denote the precedence of the operators as in table \ref{tab:op_precedence}. The operators are listed by importance, top to bottom. Each operator is given a precedence score ranging from \(1-8\). Finally each operator will have its associativity denoted. According to the assignment, all of the binary operators should be left-associative.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Name & Precedence & Associativity\\
\hline
TIMES & 1 & Left\\
DIVIDE & 1 & Left\\
PLUS & 2 & Left\\
MINUS & 2 & Left\\
EQUAL & 3 & Left\\
LESS & 3 & Left\\
NOT & 4 & Left\\
AND & 5 & Left\\
OR & 6 & Left\\
ELSE & 7 & Non Associative\\
OptElse & 8 & Non Associative\\
\hline
\end{tabular}
\end{center}
\caption{\label{tab:op_precedence}Operator Precedence}
\end{table}

%\subsubsection{}

\subsubsection{Productions}
Last task for making the compiler is to write down each of the productions. We ran into a few problems with the handed out language, with both the operators between expression $Exp \rightarrow Exp \text{ OP } Exp$ but also $Exp \rightarrow LVal$.

\subsection{Linking parser}
The last step to create a new parser, is to link the compiler to use the new implementation of the SLR(1) parser, instead of the handed out LL(1) parser. This was done in the file \textit{"Driver.sml"}.

\subsection{Integer multiplication/division}
The multiplication and division is both fully supported by the parser, next step is to implement the feature in the type checker.

\subsection{Boolean operators}
Boolean operators is now fully supported by the lexer and parser. The next task to implement this feature is to implement the type checking for these operations.

\subsection{Type inteference}

\subsection{Type checking}
\subsection{Array indexing}
\subsection{Call-by-value-result semantics}

\section{Testing}
We have tested our parser implementation with the included test file \textit{"parserTest.pal"}. This file is testing pretty much all of the different productions used in the language. We got almost all of them to work, but since we haven't implemented some few things in the type checker, we cannot run the program with some of the operations. Or and Not are two examples of this. Instead we denoted that the compiler would say typechecker failure and not parser error, when compiling - since its a typechecker error, it means the parser succesfully parsed the input.

\section{Conclusion}
The milestone has been met, according to the assignment specification. The tests clearly indicate this.

%\section{Bibliography}
\begin{thebibliography}{9}
\bibitem{springer2011}
Torben Ægidius Mogensen,
\emph{Introduction to Compiler Design}.
Springer London,
2011.
\end{thebibliography}


%\section{Appendix A: }
%Write here \ldots

\end{document}
