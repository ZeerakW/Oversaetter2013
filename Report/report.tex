\documentclass[10pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{array}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{epstopdf}
%\usepackage{minted}
\usepackage{verbments}

\title{A Compiler for the \textbf{Paladim} Language}
\author{
    Klaus Møllnitz\\
    nhg665
  \and
    Konstantin Slavin-Borovskij\\
    wfb603
  \and
    Zeerak Waseem\\
    csp265
}
\begin{document}
\maketitle

\newpage
\tableofcontents
\section{Introduction}
In this report we will document the changes we have made to the Paladim language. 

We were given the assignment to implement certain tasks. For this report, we were asked to implement a parser, integer multiplication, division, and boolean operators, type inference and type checking for the \texttt{new} function, type checking and array indexing, and call-by-value-result semantics for procedures in the Paladim compiler.\\

We have written our testing section for each sub section in the analysis, so as to add a greater coherence between the implemented tasks and the test of these. All edited code can be found in the appendices.

\section{Background}

We will briefly introduce the nature of the changes for each of the tasks given. The tasks given were:
\begin{itemize}
\item Implement a parser for the Paldim language
\item Implement integer division and multiplication and boolean operators in the Paladim compiler
\item Type inference and type checking for the \texttt{new} function
\item Type checking and code generation for Array Indexing
\item Call-By-Value-Result semantics for procedures
\end{itemize}

% TODO Add parser.grm to appendices label: Appendix:Parser.grm
The parser was implemented by creating a new grammar file, which can be seen in \ref{Appendix:Parser.grm}. It can also be found in the \texttt{SRC} folder.\\

% TODO Integer Multiplication, division and boolean operation need to be explained
For the integer multiplication, division and boolean operations; we initially edited the \texttt{TpAbsyn.sml} file to reflect the operations we wished to implement (\texttt{times, divide, or, not}), we then edited Compiler.sml, where we implemented the translation to \texttt{MIPS}, we then edited \texttt{TpInterpret.sml} where we implemented the interpretation, finally we edited \texttt{Type.sml} where we ensure that the types correspond to the desired values.\\ 
% TODO Type inference and type checking for the new function need to be explained
For the \texttt{new \& read} functions, we edit \texttt{Type.sml} as we are to implement simple type inference and type checking. This is done in \texttt{typeCheckExp}.
% TODO Type checking and array indexing need to be explained
To implement type checking and array indexing for arrays, we edited \texttt{Type.sml} to reflect required changes for array handling. Further, we edited the \texttt{compileLVal} function in \texttt{Compiler.sml} to support translation to machine code.\\

% TODO Call-By-Value-Result semantics for procedures
To implement Call-By-Value-Result semantics we have edited \texttt{TypeInterpret.sml}, implementing \texttt{updateOuterVtable}. Furthermore we have also extended \texttt{Compiler.sml} to support code generation for Call-By-Value-Result interpretation, by implementing a new function named \texttt{rePutArgs}. 

\section{Analysis}
\subsection{Parser}
\subsubsection{Identifying tokens}
In our abstract parser definition most of our tokens use the type $<int*int>$. This type is the position of the token, which is constructed by line and column. If nothing is stated in the tables, this is the type used.

We have identified the list of terminals and given each a keyword, for later use in the abstract parser definition.

All the keywords of the Paladim language is listed in table \ref{tab:keywords}, these only use the positional data, meaning they all have token type $<int*int>$, since we have chosen to denote the position by linenumber and column in the line.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\textbf{program} & PROGRAM \\
\textbf{function} & FUNCTION \\
\textbf{procedure} & PROCEDURE \\
\textbf{var} & VAR \\
\textbf{begin} & BEGIN \\
\textbf{end} & END \\
\textbf{if} & IF \\
\textbf{then} & THEN \\
\textbf{else} & ELSE \\
\textbf{while} & WHILE \\
\textbf{do} & DO \\
\textbf{return} & RETURN \\
\hline
\end{tabular}
\caption{\label{tab:keywords}Keywords}
\end{table}

We also need keywords for the specific types, since we should be able to write the following as noted in (\ref{eq:varname_type}). The keyword is written in Table \ref{tab:type_keywords}.
\begin{align}
\label{eq:varname_type}
\text{VariableName} \textbf{ : } \text{Type}. 
\end{align}

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\textbf{int} & INT \\
\textbf{char} & CHAR \\
\textbf{bool} & BOOL \\
\textbf{array of} & ARRAYOF \\
\textbf{of} & OF \\
\hline
\end{tabular}
\caption{\label{tab:type_keywords}Type keywords}
\end{table}

Next terminals we need to consider is symbols. These are very simple and shown in table \ref{tab:symbols}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\textbf{;} & SEMICOLON \\
\textbf{:} & COLON \\
\textbf{,} & COMMA \\
\textbf{:=} & ASSIGN \\
\textbf{EOF} & EOF \\
\hline
\end{tabular}
\caption{\label{tab:symbols}Symbols}
\end{table}

All arithmetic operators is found in table \ref{tab:arithmetics}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\text{+} & PLUS \\
\text{-} & MINUS \\
\text{*} & TIMES \\
\text{/} & DIVIDE \\
\text{=} & EQUAL \\
\text{<} & LESS \\
\textbf{AND} & AND \\
\textbf{OR} & OR \\
\textbf{NOT} & NOT \\
\hline
\end{tabular}
\caption{\label{tab:arithmetics}Arithmetics}
\end{table}

Parantheses is covered in table \ref{tab:parentheses}. They have been given their own table as to represent the structure of the lexer. 

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\text{(} & LPAR \\
\text{)} & RPAR \\
\text{\{} & LCBR \\
\text{\}} & RCBR \\
\text{[} & LBRA \\
\text{]} & RBRA \\
\hline
\end{tabular}
\caption{\label{tab:parentheses}Parentheses}
\end{table}

Finally we have all of the literals, which are supposed to contain both data and a position. As seen in table \ref{tab:literals}, they all make use of some sort of variable to store their content. We also cover the Identifier here.

\begin{table}[!h]
\centering
\begin{tabular}{|c|c|c|}
\hline
Terminal & Keyword & Type\\
\hline
\textbf{ID} & ID & <string*(int*int)>\\
\textbf{NUMLIT} & NUMLIT & <int*(int*int)>\\
\textbf{LOGICLIT} & LOGLIT & <bool*(int*int)> \\
\textbf{CHARLIT} & CHALIT & <char*(int*int)> \\
\textbf{STRINGLIT} & STRLIT & <string*(int*int)> \\
\hline
\end{tabular}
\caption{\label{tab:literals}Literals}
\end{table}

\subsubsection{Precedence}
Next task is to denote the precedence of the operators as in table \ref{tab:op_precedence}. The operators are listed by importance, top to bottom. Each operator is given a precedence score ranging from \(1-8\). Finally each operator will have its associativity denoted. According to the assignment, all of the binary operators should be left-associative.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Name & Precedence & Associativity\\
\hline
TIMES & 1 & Left\\
DIVIDE & 1 & Left\\
PLUS & 2 & Left\\
MINUS & 2 & Left\\
EQUAL & 3 & Left\\
LESS & 3 & Left\\
NOT & 4 & Left\\
AND & 5 & Left\\
OR & 6 & Left\\
ELSE & 7 & Non Associative\\
OptElse & 8 & Non Associative\\
\hline
\end{tabular}
\end{center}
\caption{\label{tab:op_precedence}Operator Precedence}
\end{table}

%\subsubsection{}

\subsubsection{Productions}
Last task for making the compiler is to write down each of the productions. We ran into a few problems with the handed out language, with both the operators between expression $Exp \rightarrow Exp \text{ OP } Exp$ but also $Exp \rightarrow LVal$.

\subsubsection{Linking parser}
The last step to create a new parser, is to link the compiler to use the new implementation of the SLR(1) parser, instead of the handed out LL(1) parser. This was done in the file \textit{"Driver.sml"}.

\subsubsection{Testing Parser}
We have tested our parser implementation with the included test file \textit{"parserTest.pal"}. This file is testing pretty much all of the different productions used in the language. We got almost all of them to work, but since we haven't implemented some few things in the type checker, we cannot run the program with some of the operations. Or and Not are two examples of this. Instead we denoted that the compiler would say typechecker failure and not parser error, when compiling - since its a typechecker error, it means the parser succesfully parsed the input.

\subsection{Integer multiplication/division}
The multiplication and division is both fully supported by the parser, next step is to implement the feature in the type checker.\\

To implement the feature in the Paladim compiler, we initially edited the \texttt{TpAbsyn.sml} adding \texttt{Times \& Div} types to the \texttt{typeOfExp} function. We then edit \texttt{Type.sml} extending \texttt{typeCheckExp}. We do type check recursively on the expressions on both sides of the multiplication or the division operator, to ensure that both expression types are of type \texttt{INT}.\\
Then we edited \texttt{TpInterpret.sml} to implement the formula(\ref{slide:interpretation})
\begin{align}
Eval_{exp}(Exp, vtable, ftable) =& Exp_1 binop Exp_2\\
v1 =& Eval_{Exp} (Exp_1, vtable, ftable)\label{formula:v1}\\
v2 =& Eval_{Exp} (Exp_2, vtable, ftable)\label{formula:v2}
\end{align}
then running the function \texttt{evalBinop} on the operator and the results of the recursive calls to \texttt{evalExp} (gained from \ref{formula:v1} and \ref{formula:v2}).\\

Finally we edited the \texttt{Compilers.sml} file, we recursively translate the expressions on each side of the operator and append the code for each translated expression to a list, to which we finally append the corresponding \texttt{MIPS} instruction.

The same has been done for the \texttt{or \& not} operators, correspondingly changing the typecheck from \texttt{INT} to \texttt{BOOL}. Furthermore, seeing as \texttt{not} is a unary operator we have ensured that the check is only done for one expression, rather than two, as with the rest of the operators we were to implement. Finally, we in \texttt{Compiler.sml} we have implemented the translation to machine code for \texttt{or} inspired by the given implementation for \texttt{and}. \texttt{not} is implemented by using the \texttt{xori} instruction from the \texttt{MIPS} library, \texttt{xor-ing 1} on the register containing the value to be negated.

\subsubsection{Boolean operators}
Boolean operators is now fully supported by the lexer and parser. The next task to implement this feature is to implement the type checking for these operations.

The \texttt{or} operator is very 


\subsubsection{Testing Multiplication, Division, and Boolean Operators}

\subsection{Type inference \& Type Checking}
\subsubsection{Type Inference}
\subsubsection{Type checking}
* To check the type we needed to add support for checking the type of Or and Not in TpAbSyn
* We also uncommented Or and Not in the TpAbSyn structure

Interpreter:
It is important to add pretty printing functionality for all new expressions, since the TpInterpreter is using these functions to print the code being interpreted.
\subsubsection{Testing Type Inference \& Type Checking}
\subsection{Array Indexing}
\subsubsection{Testing Array Indexing}
\subsection{Call-by-value-result semantics}
\subsubsection{Testing Call-by-Value-Result semantics}

\section{Conclusion}
The milestone has been met, according to the assignment specification. The tests clearly indicate this.

%\section{Bibliography}
\begin{thebibliography}{9}
\bibitem{springer2011}
Torben Ægidius Mogensen,
\emph{Introduction to Compiler Design}.
Springer London,
2011.

%\bibitem{slide:interpretation}
\end{thebibliography}


%\section{Appendix A: }
%Write here \ldots

\end{document}
