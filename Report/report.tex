\documentclass[10pt]{article}
\usepackage[margin=3cm]{geometry}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{array}
\usepackage{amsmath}
\usepackage{xcolor}
\usepackage{hyperref}
\usepackage{graphicx}
\usepackage{epstopdf}
%\usepackage{minted}
\usepackage{verbments}

\title{A Compiler for the \textbf{Paladim} Language}
\author{
    Klaus Møllnitz\\
    nhg665
  \and
    Konstantin Slavin-Borovskij\\
    wfb603
  \and
    Zeerak Waseem\\
    csp265
}
\begin{document}
\maketitle

\newpage
\tableofcontents
\section{Introduction}
In this report we will document the changes we have made to the Paladim language. 

We were given the assignment to implement certain tasks. For this report, we were asked to implement a parser, integer multiplication, division, and boolean operators, type inference and type checking for the \texttt{new} function, type checking and array indexing, and call-by-value-result semantics for procedures in the Paladim compiler.

We have written our testing section for each sub section in the analysis, so as to add a greater coherence between the implemented tasks and the test of these. All edited code can be found in the appendices.

\section{Background}

We will briefly introduce the nature of the changes for each of the tasks given. The tasks given were:
\begin{itemize}
\item Implement a parser for the Paldim language
\item Implement integer division and multiplication and boolean operators in the Paladim compiler
\item Type inference and type checking for the \texttt{new} function
\item Type checking and code generation for Array Indexing
\item Call-By-Value-Result semantics for procedures
\end{itemize}

% TODO Add parser.grm to appendices label: Appendix:Parser.grm
The parser was implemented by creating a new grammar file, which can be seen in \ref{Appendix:Parser.grm}. It can also be found in the \texttt{SRC} folder.

% TODO Integer Multiplication, division and boolean operation need to be explained
For the integer multiplication, division and boolean operations; we initially edited the \texttt{TpAbsyn.sml} file to reflect the operations we wished to implement (\texttt{times, divide, or, not}), we then edited Compiler.sml, where we implemented the translation to \texttt{MIPS}, we then edited \texttt{TpInterpret.sml} where we implemented the interpretation, finally we edited \texttt{Type.sml} where we ensure that the types correspond to the desired values.

% TODO Type inference and type checking for the new function need to be explained
For the \texttt{new \& read} functions, we edited \texttt{Type.sml} to implement simple type inference and type checking. This is done in \texttt{typeCheckExp}.

% TODO Type checking and array indexing need to be explained
To implement type checking and array indexing for arrays, we edited \texttt{Type.sml} to reflect required changes for array handling. Further, we edited the \texttt{compileLVal} function in \texttt{Compiler.sml} to support translation to machine code.

% TODO Call-By-Value-Result semantics for procedures
To implement Call-By-Value-Result semantics we have edited \texttt{TpInterpret.sml}, implementing \texttt{updateOuterVtable}. Furthermore we have also extended \texttt{Compiler.sml} to support code generation for Call-By-Value-Result interpretation, by implementing a new function named \texttt{rePutArgs}.

\section{Analysis}
\subsection{Parser}
\subsubsection{Identifying tokens}
In our abstract parser definition most of our tokens use the type $<int*int>$. This type is the position of the token, which is constructed by line and column. If nothing is stated in the tables, this is the type used.

We have identified the list of terminals and given each a keyword, for later use in the abstract parser definition.

All the keywords of the Paladim language is listed in table \ref{tab:keywords}, these only use the positional data, meaning they all have token type $<int*int>$, since we have chosen to denote the position by linenumber and column in the line.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\textbf{program} & PROGRAM \\
\textbf{function} & FUNCTION \\
\textbf{procedure} & PROCEDURE \\
\textbf{var} & VAR \\
\textbf{begin} & BEGIN \\
\textbf{end} & END \\
\textbf{if} & IF \\
\textbf{then} & THEN \\
\textbf{else} & ELSE \\
\textbf{while} & WHILE \\
\textbf{do} & DO \\
\textbf{return} & RETURN \\
\hline
\end{tabular}
\caption{\label{tab:keywords}Keywords}
\end{table}

We also need keywords for the specific types, since we should be able to write the following as noted in (\ref{eq:varname_type}). The keyword is written in table \ref{tab:type_keywords}.
\begin{align}
\label{eq:varname_type}
\text{VariableName} \textbf{ : } \text{Type}. 
\end{align}

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\textbf{int} & INT \\
\textbf{char} & CHAR \\
\textbf{bool} & BOOL \\
\textbf{array} & ARRAY \\
\textbf{of} & OF \\
\hline
\end{tabular}
\caption{\label{tab:type_keywords}Type keywords}
\end{table}

Next terminals we need to consider is symbols. These are very simple and shown in table \ref{tab:symbols}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\textbf{;} & SEMICOLON \\
\textbf{:} & COLON \\
\textbf{,} & COMMA \\
\textbf{:=} & ASSIGN \\
\textbf{EOF} & EOF \\
\hline
\end{tabular}
\caption{\label{tab:symbols}Symbols}
\end{table}

All arithmetic operators is found in table \ref{tab:arithmetics}.

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\text{+} & PLUS \\
\text{-} & MINUS \\
\text{*} & TIMES \\
\text{/} & DIVIDE \\
\text{=} & EQUAL \\
\text{<} & LESS \\
\textbf{AND} & AND \\
\textbf{OR} & OR \\
\textbf{NOT} & NOT \\
\hline
\end{tabular}
\caption{\label{tab:arithmetics}Arithmetics}
\end{table}

Parantheses is covered in table \ref{tab:parentheses}. They have been given their own table as to represent the structure of the lexer. 

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|}
\hline
Terminal & Keyword \\
\hline
\text{(} & LPAR \\
\text{)} & RPAR \\
\text{\{} & LCBR \\
\text{\}} & RCBR \\
\text{[} & LBRA \\
\text{]} & RBRA \\
\hline
\end{tabular}
\caption{\label{tab:parentheses}Parentheses}
\end{table}

Finally we have all of the literals, which are supposed to contain both data and a position. As seen in table \ref{tab:literals}, they all make use of some sort of variable to store their content. We also cover the Identifier here.

\begin{table}[!h]
\centering
\begin{tabular}{|c|c|c|}
\hline
Terminal & Keyword & Type\\
\hline
\textbf{ID} & ID & <string*(int*int)>\\
\textbf{NUMLIT} & NUMLIT & <int*(int*int)>\\
\textbf{LOGICLIT} & LOGLIT & <bool*(int*int)> \\
\textbf{CHARLIT} & CHALIT & <char*(int*int)> \\
\textbf{STRINGLIT} & STRLIT & <string*(int*int)> \\
\hline
\end{tabular}
\caption{\label{tab:literals}Literals}
\end{table}

\subsubsection{Precedence}
Next task is to denote the precedence of the operators as in table \ref{tab:op_precedence}. The operators are listed by importance, top to bottom. Each operator is given a precedence score ranging from \(1-8\). Finally each operator will have its associativity denoted. According to the assignment, all of the binary operators should be left-associative.

\begin{table}
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Name & Precedence & Associativity\\
\hline
TIMES & 1 & Left\\
DIVIDE & 1 & Left\\
PLUS & 2 & Left\\
MINUS & 2 & Left\\
EQUAL & 3 & Left\\
LESS & 3 & Left\\
NOT & 4 & Left\\
AND & 5 & Left\\
OR & 6 & Left\\
ELSE & 7 & Non Associative\\
OptElse & 8 & Non Associative\\
\hline
\end{tabular}
\end{center}
\caption{\label{tab:op_precedence}Operator Precedence}
\end{table}

\subsubsection{Productions}
Last task for making the compiler is to write down each of the productions. We ran into a few problems with the handed out language, with both the operators between expression $Exp \rightarrow Exp \text{ OP } Exp$ but also $Exp \rightarrow LVal$. These issues got solved, by substituting the productions into the production for $Exp$.

\subsubsection{Linking parser}
The last step to create a new parser, is to link the compiler to use the new implementation of the SLR(1) parser, instead of the handed out LL(1) parser. This was done in the file \textit{"Driver.sml"}.

\subsubsection{Testing Parser}
We have tested our parser implementation with a new test file we have created for the purpose, called \textit{"parserTest.pal"}. This file is testing pretty much all of the different productions used in the language. We got all of them to work like they should. To test the parser while the type checker was not implemented, we simply noted if the Paladim program would fail with \texttt{parser error} or \texttt{type checking error}, if the last was the case, it meant the parser did the job correctly since its a typechecker error, hence the compiler proceeded after parse checking.

\subsection{Integer multiplication/division and boolean operators}
The multiplication, division and boolean operators is all fully supported by the parser, next task is to implement the features in the type checker.

To implement the features in the Paladim compiler, we initially edited the typed abstract syntax tree, \texttt{TpAbsyn.sml}, by adding \texttt{Times \& Div} types to the \texttt{typeOfExp} function. This function should simply just return the type of first operand, since the type check makes sure both operands are of same type. Another important thing to add in this file is the pretty printing of the expressions, since the Interpreter is using the pretty printing functionsto show the code to the user. It is done in a similar matter to the pretty printing of \texttt{Plus} and \texttt{Minus}.

We then edited the type checker, \texttt{Type.sml}, extending the function \texttt{typeCheckExp}. The two functions is implemented by doing a type check recursively of the expressions on both sides of the multiplication or the division operator. The results is compared with the type \texttt{INT}, to make sure both have correct type, if this is not the case we raise an error.

The same has been done for the \texttt{OR \& NOT} operators, correspondingly changing the typecheck from \texttt{INT} to \texttt{BOOL}. Furthermore, seeing as \texttt{NOT} is a unary operator we have ensured that the check is only done for one expression, rather than two, as with the rest of the operators we were to implement.

\subsubsection{Multiplication, division and boolean operators in interpreter}
Since multiplication, division and the boolean operators is now implemented in the type checker, it needs to be implemented in the compiler and the interpreter. Here we cover how we achieved this in the interpreter. The interpreter is implemented in the file \texttt{TpInterpret.sml}, hence we need to add the missing functions in there.

The interpreter can expect to get type checked expression, therefore we can simply just evaluate each operand of the expression, and calculate the result, just like with \texttt{Plus} and \texttt{Minus}. This is very trivial for both, the only thing to note here, is in division we have to use the SML function called div, since we are interested in integer division and not floating point division.

Finally we also need to implement the boolean operators in the interpreter. Since the boolean operator \texttt{AND} is already implemented, we decided to implement \texttt{OR} and \texttt{NOT} in the same style, by having a function to evaluate each of the expression respectively \texttt{evalOR} and \texttt{evalNOT}. These helper functions simply calculate \texttt{OR} and \texttt{NOT} by using the SML functions \texttt{orelse} and \texttt{not}. The interpreter is evaluating each of the operands to the function before calling the helper functions, which means the helper function is simply gonna get one or two arguments respectively.
% TODO, maybe add some lines of code to show proof-of-concept

\subsubsection{Multiplication, division and boolean operators in compiler}
Finally to implement the features in the compiler, we edited the \texttt{Compilers.sml} file.

To implement the boolean operators in the compiler, we used the same approach as with the \texttt{AND} operator. The function should return a list of Mips instructions to achieve this task, hence the beginning of the list should be the output of the function \texttt{compileExp} with the first operand as argument. The list is then followed with some code that check if the first operand is different from zero (meaning the expression is true), if this is the case, it would branch to a label in the end of the expression, since there is no need to check more. If the first operand is indeed zero, there should be no branching, and the second operand should be checked, hence the result is that of \texttt{compileExp} of second operand.

The expression \texttt{NOT} is implemented in a similar manner, by using the \texttt{XORI} instruction from the \texttt{MIPS} library on the register containing the value to be negated (by using the function \texttt{compileExp}.

Muliplication and division is a bit more simple, they basically just compile each of the operands with \texttt{compileExp}, and then append the \texttt{MIPS} instructions \texttt{MUL} and \texttt{DIV} accordingly.

\subsubsection{Testing Multiplication, Division, and Boolean Operators}
A number of tests was done, to check that the multiply and divide operators, as well as the boolean operators \texttt{OR \& NOT}, are behaving as expected. The tests is available in \texttt{DATA\\parserTest.pal}, which both test a lot of parser-related functionality, but also includes testing of the aforementioned operators.\\

This results does not need much explanation, as the expected results are trivial. But running the tests, confirm that the operators behave as desired.

% TODO I'm working here !! :) - Klaus
\subsection{Type inference \& Type Checking}
This section explaines how we chose to implement type inference and type checking, focusing on what was needed to implement these properties into the Paladim compiler.\\
The implementation for type checking of the \texttt{read}-function, was done in \texttt{Type.sml}. The type checking is done by checking what type expression is passed to the function, and from that determining an expected type of \texttt{read}. If the expression contains a specific operator, it is possible to determine what type, the subexpression are expected to be, and let \texttt{read} inherit this property.\\
For simplicity, the type checking implemented, only works if it is possible to determine at least the right-hand side of an expression, as implementing all possible cases was not required. This means, that the left-hand subexpression determines the expected type of the right-hand side subexpression. Furthermore, since it there is no unique way of determining the type of an expression like \texttt{read OP read}, there is no implementation to deal with this case, and the type checking will most likely fail.\\
The function \texttt{new} is also implemented by extending the \texttt{typeCheckExp}-function in \texttt{Type.sml}. The function recursively checks all the arguments of the \texttt{new}-function, by generating a new list of the arguments, and checking that all of these are \texttt{INTs}. Then it checks what \texttt{new} should return, and creates a new array, where the allocation of the element size, is dependent on the return type.
\subsubsection{Type Inference}
%Er det nødvendig med de 2 subsections her?
\subsubsection{Type checking}

%Det nedenunder ved jeg ikke lige hvor hører til
Interpreter:
It is important to add pretty printing functionality for all new expressions, since the TpInterpreter is using these functions to print the code being interpreted.
\subsubsection{Testing Type Inference \& Type Checking}
The testing of type inference and type checking is done in \texttt{DATA\\parterTest.pal}, line 87-103 (Linjenumre?). The expected results are !!!BLA BLA BLA!!!. And as it can be seen, by running the tests, this is what they return.
\subsection{Array Indexing}
\subsubsection{Testing Array Indexing}
\subsection{Call-by-value-result semantics}
\subsubsection{Testing Call-by-Value-Result semantics}

\section{Conclusion}
The milestone has been met, according to the assignment specification. The tests clearly indicate this.

%\section{Bibliography}
\begin{thebibliography}{9}
\bibitem{springer2011}
Torben Ægidius Mogensen,
\emph{Introduction to Compiler Design}.
Springer London,
2011.

%\bibitem{slide:interpretation}
\end{thebibliography}


%\section{Appendix A: }
%Write here \ldots

\end{document}
