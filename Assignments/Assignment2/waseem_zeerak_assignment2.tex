\documentclass{article}
\usepackage{graphicx}
\usepackage[dot, autosize, outputdir="graphfiles/"]{dot2texi}
\usepackage{tikz}
\usepackage{amsmath, mathtools}
\usetikzlibrary{shapes}
\title{W2 Resubmission}
\author{Zeerak Waseem - csp265}
\begin{document}
\maketitle
\newpage
\section{Writing Context Free Grammars}
Write grammars over the alphabet \(\sum = \{a, b, c\}\)
\subsection{Words which contain more a's than b's}
We identify that for each production that contains a 'b' the production must also contain an 'a'.
\begin{align*}
S &= aS\\
S &= aT\\
T &= aTb\\
T &= \epsilon
\end{align*}
See the grammarfile \texttt{a.grm}
\subsection{Words that are palindromes}
We identify that asides from a single character, all letters must be produced twice, one for each side of the singular character.\\
It is clear that this language will cause conflicts, as it is not \(LR(1)\) or \(LL(1)\).
\begin{align*}
S &= A | B | C | a | b | c | \epsilon\\
A &= aSa\\
B &= bSb\\
C &= cSc\\
\end{align*}
See the grammarfile \texttt{b.grm}
\section{\(LL(1)\)-parser construction}
The grammar:
\begin{align*}
Z &\rightarrow b | X\; Y\; Z\\
Y &\rightarrow \epsilon | c\\
X &\rightarrow Y | a\\
\end{align*}
\subsection{Determine which Nonterminals are nullable and calculate First sets of all right-hand sides of the productions}
We start by assuming that no nonterminals are nullable, then we use \texttt{algorithm 2.4} to calculate the right hand sides, updating the values on the left hand side, when needed.

\begin{align*}
nullable(Z) &= nullable(b) \vee nullable(XYZ)\\
nullable(Y) &= nullable(\epsilon) \vee nullable(c)\\
nullable(X) &= nullable(Y) \vee nullable(a)
\end{align*}

Now we determine whether the equations above are true.
\begin{align*}
nullable(b) &= False\\
nullable(XYZ) &= nullable(X)\wedge nullable(Y)\wedge nullable(Z)\\
nullable(\epsilon) &= True\\
nullable(c) &= False\\
nullable(a) &= False
\end{align*}

We then utilize fixed-point iteration (shown in a table) to determine whether the states change.
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
RHS &Â Init & It. 1 & it. 2 & It. 3 & It. 4 & It. 5\\
\hline
b & false & false & false & false & false & false\\
\hline
XYZ & false & false & false & false & false & false\\
\hline
\(\epsilon\) & false & true & true & true & true & true\\
\hline
c & false & false & false & false & false & false\\
\hline
Y & false & false & false & true & true & true\\
\hline
Nonterminals & & & & & & \\
\hline
X & false & false & false & false & true & true\\
\hline
Y & false & false & true & true & true & true\\
\hline
Z & false & false & false & false & false & false\\
\hline
\end{tabular}
\end{center}
\end{table}
As we can see, the fourth and fifth iteration introduce no changes, so we can stop our calculation at the firth iteration. Thus, our result is:
\begin{align*}
nullable(X) &= True\\
nullable(Y) &= True\\
nullable(Z) &= False
\end{align*}

We now wish to calculate the first sets of the right hand sides, for this we use \texttt{algorithm 2.5}.
\begin{align*}
first(b) &= \{b\}\\
first(XYZ) &= first(X) \cup first(Y) \cup first(Z)\\
first(\epsilon) &= \{\emptyset\}\\
first(c) &= \{c\}\\
first(a) &= \{a\}
\end{align*}
We use fixed-point iteration to determine the sets
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
RHS & Init & It. 1 & It. 2 & It. 3 & It. 4 & It. 5\\
\hline
b & \(\emptyset\) & b & b & a & a & a\\
\hline
XYZ & \(\emptyset\) & \(\emptyset\) & \(\emptyset\) & a, b, c & a, b, c & a, b, c\\
\hline
\(\epsilon\) & $\emptyset$ & $\emptyset$ & $\emptyset$ & $\emptyset$ & $\emptyset$ & $\emptyset$\\
\hline
c & $\emptyset$ & c & c & c & c & c\\
\hline
Y & $\emptyset$ & $\emptyset$ & $\emptyset$ & c & c & c\\
\hline
a & $\emptyset$ & a & a & a & a & a\\
\hline
Nonterminals & & & & & &\\
\hline
X & $\emptyset$ & $\emptyset$ & a & a & a, c & a, c\\
\hline
Y & $\emptyset$ & $\emptyset$ & c & c & c & c\\
\hline
Z & $\emptyset$ & $\emptyset$ & b & b & a, b, c & a, b, c\\
\hline
\end{tabular}
\end{center}
\end{table} 

Thus, the first sets are:
\begin{align*}
first(b) =& \{b\}\\
first(XYZ) =& \{a,b,c\}\\
first(\epsilon) =& \emptyset\\
first(c) =& \{c\}\\
first(Y) =& \{c\}\\
first(a) =& \{a\}
\end{align*}
\subsection{Calculate Follow sets for all nonterminals (adding an extra start production to recognise the end of the input, denoted by "\$")}

Given our grammar, the follow sets are quite easily calculated. An extra nontermianl \(Z'\rightarrow Z\$\) has been added.
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|}
\hline
Nonterminal & Follow set & Constraint\\
\hline
Z & \{\$\} & Follow(Z) = Follow(Z)\\
\hline
Y & \{a, b, c\} & Follow(X) \(\subseteq\) Follow(Y)\\
\hline
X & \{a, b, c\} & \\
\hline
\end{tabular}
\end{center}
\end{table}
\subsection{Determine the look-aheads sets of all productions and put together a parse table for a predictive parser (as shown in the lecture slides)}
\begin{align*}
la(Z\rightarrow b) =& First(b) = \{b\}\\
la(Z\rightarrow XYZ) =& First(XYZ) \cup Follow(Z) = \{a,b,c,\$\}\\
la(Y\rightarrow c) =& First(c) = \{c\}\\
la(y\rightarrow \epsilon) =& First(\epsilon) \cup Follow(Y) = \{a, b, c\}\\
la(X\rightarrow Y) =& First(Y) \cup Follow(X) = \{a, b, c\}\\
la(X\rightarrow a) =& First(a) = \{a\}
\end{align*}
I'm unsure of how to create a parser table, but this is my attempt.
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|}
\hline
Stack & a & b & c & \$\\
\hline
Z & XYZ, 2 & XYZ, 2; b, 1 & XYZ, 2 & error\\
\hline
Y & $\epsilon$, 3 & $\epsilon$, 3 & $\epsilon$, 3; c, 4 & error\\
\hline
X & Y, 5; a, 6 & Y, 5 & Y, 5 & error\\
\hline
a & pop & & & \\
\hline
b & & pop & & \\
\hline
c & & & pop & \\
\hline
\$ & & & & accept\\
\hline
\end{tabular}
\end{center}
\end{table} 

\section{SLR Parser Construction}
My grammer:
\begin{align*}
S &\rightarrow Sa\\
S &\rightarrow \epsilon
\end{align*}

\subsection{Show that your grammar does not generate conflicts (by providing a parse table)}
\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
& 001 & a & \(\epsilon\) & \$ & S & entry\\
S0 & S1 &  & & & & S2\\
\hline 
S1 & & S3 & & reduce 2 & S4 & \\
\hline
S2 & & & & accept & & \\
\hline
S3 & & s3 & & reduce 2 & S5 & \\
\hline
S4 & & & reduce 3 & & & \\
\hline
S5 & & & reduce 1 & & & \\
\hline 
\end{tabular}
\end{center}
\end{table}

As seen there are no conflicts. This parser table is gathered from the output file generated by mosmlyac with the flag -v set.
\subsection{Compare your grammar to an equivalent one that uses right-recursion. How does the parse stack grow when parsing input?}

\begin{align*}
S &\rightarrow aS\\
S &\rightarrow \epsilon
\end{align*}

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|c|c|c|c|c|c|}
\hline
& 001 & a & \(\epsilon\) & \$ & S & entry\\
\hline
S0 & S1 &  & & & & S2\\
\hline
S1 & & S3 & & reduce 2 & S4 & \\
\hline
S2 & & & & accept & & \\
\hline
S3 & & S3 & & reduce 2 & S5 & \\
\hline
S4 & & & reduce 3 & & & \\
\hline
S5 & & & reduce 1 & & & \\
\hline
\end{tabular}
\end{center}
\end{table}
It is seen that the right recursive grammar builds up a stack before reducing it, while the left recursive reduces from the word go. 
\end{document}
